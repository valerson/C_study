***** ***** *****
Начало работы
Создание нового репозитория, первый коммит, привязка удалённого репозитория с github.com, отправка изменений в удалённый репозиторий.

# указана последовательность действий:
# создана директория проекта, мы в ней
git init                      	# создаём репозиторий в этой директории
touch readme.md               	# создаем файл readme.md
git add readme.md             	# добавляем файл в индекс
git commit -m "Старт"         	# создаем коммит
git branch -M main		# переименовываем ветку master в main
git remote add origin https://github.com/valerson/git_repo_study.git 
			      	# добавляем предварительно созданный пустой удаленный репозиторий
git push -u origin main     	# отправляем данные из локального репозитория в удаленный (в ветку main) если не сработает main делай master

git remote rm origin 		# эта команда удалит текущий origin
ЕСЛИ ВЕТОК НЕСКОЛЬКО -  ПЕРЕХОДИ ВНУЖНУЮ И ДЕЛАЙ git push -u origin <НАЗВАНИЕ ВЕТКИ>

***** ***** *****
Добавление изменений в репозиторий на github.com

git status			# смотрим куыещку чтобы какие файлы изменились и добавились
git add --all             	# добавляем все файлы в индекс или перечисляем каждый (муть)
git commit -m "пишем, что изменилось"
		         	# создаем новый коммит с комментарием
git push -u origin main     	# отправляем данные из локального репозитория в удаленный (в ветку main)

***** ***** *****
Загрузка репозитория на компе
# создана директория проекта, мы в ней
git clone https://github.com/valerson/git_repo_study.git
				# копируем репозиторий из github.com на локальную машину

***** ***** *****
git log 			# появляется список коммитов
git log --oneline		# появляется список коммитов с краткими логами (читабельнее)


***** ***** *****
Если коммит еще не опубликован и требуется в него внести изменения
git add common.css 		# добавили файл common.css в список на коммит как обычно
git commit --amend --no-edit	# опция --amend добавляет в коммит файлы. 
				--no-edit оставляет комментарий без изменений или -m "Новое сообщение".
git restore --staged <file>	# исключить <file> из списка на коммита. если коммит уже сформирован команда не работает
git restore --staged .		# сбросит всю текущую папку
git reset --hard <commit hash>	# откатить последний коммит до состояния репозитория commit hash взять из git log --oneline вставлять хеш предпоследнего коммита
git restore <file>		# откатить изменения в файле до состояния сохраненного в коммите

***** ***** *****
git diff			# покажет в терминале изменения в файлах между сохраненным коммитом и текущей версией файлов
				ВНИМАНИЕ. если файл будет добавлен git add, но коммит еще не сохранен, то изменения не будут показаны.
git diff --staged		# опция --staged позволит увидеть изменения и после добавления файлов в коммит (до сохранения коммита)
git diff 9de9dc6 e2b70e0	# сравнить 2 коммита между собой. вместо лога одного из них можно использовать HEAD (последний будет)
				 
***** ***** *****
>>				# добавить в конец файла
>				# перезаписать файл
.gitignore			# файл для написания исключений из отслеживания git'ом. Каждое исключение на отдельной строке.

***** ***** *****
Работа с ветками
git branch			# выводятся ветки, которые есть в проекте. * отмечается ветка, в которой ты сейчас находишься

git branch -a			# ВСЕГДА ИСПОЛЬЗУЙ ОПЦИЮ -a покажет все ветки, в том числе скрытые

git branch <название_ветки>	# создать ветку
git checkout <название_ветки>	# переключиться на другую ветку
git checkout -b <название_ветки># создать ветку и сразу в нее перейти
commit~0 			# текущий коммит
commit~1 			# предыдущий коммит
git diff HEAD~ HEAD 		# покажет разницу между текущим коммитом и предыдущим

git merge feature/diff		#объединение веток. делается из ветки, куда вносятся изменения (обычно main). 
				из ветки feature/diff коммиты перешли в ветку main.

git branch -D <название_ветки>	# удаление ветки
git branch -d %имя_ветки%	# более безопастное удаление ветки. удалит, если ветка объединена с другой веткой


git pull			# Забрать изменения с удаленного репозитория (с github)
$ git checkout main 		# перешли в main
$ git pull 			# подтянули новые изменения в main
$ git checkout my-branch 	# вернулись в рабочую ветку my-branch
$ git merge main 		# влили main в новую ветку my-branch
$ git push -u origin my-branch 	# отправили ветку my-branch в удалённый репозиторий 

***** ***** *****
слияние веток fast-forward (когда явно нет конфликта. после создания новой ветки не было коммитов в основной).

git merge add-docs		# обычное слияние ветки main и add-docs. в ветку main будут добавлены коммиты из ветки add-docs.
git merge --no-edit --no-ff add-docs	# с опцией --no-ff fast-forward слияние юбудет отключено.
					опция --no-edit отключает ввод сообщения для merge-коммита.
					Это делается, чтобы было видно, откуда почявились коммиты в ветке main.
При слиянии не-fast-forward веток Git создаёт коммит слияния.

ОЧЕНЬ РЕДКО
git push --force		# опция --force выкиниет лишний коммит в основной ветке и сделает слияние веток fast-forward


pull (merge) request

***** ****** *****
Разрешение конфликта вручную и через vimdiff
git mergetool			# трумент слияния через редактор файла в консоли vim.
 		
 






